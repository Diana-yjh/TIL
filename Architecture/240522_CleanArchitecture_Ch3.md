# 📝 TIL - 240522 CleanArchitecture Ch.3
해당 글은 마틴 파울러의 `클린아키텍처 3부 - 설계 원칙` 을 토대로 작성되었습니다.


## 학습 내용
[1. SRP(단일 책임 원칙)](#1-SRP단일-책임-원칙)</br>
[2. OCP(개방 폐쇄 원칙)](#2-OCP개방-폐쇄-원칙)</br>
[3. LSP(리스코프 치환 원칙)](#3-LSP리스코프-치환-원칙)</br>
[4. ISP(인터페이스 분리 원칙)](#4-ISP인터페이스-분리-원칙)</br>
[5. DIP(의존성 역전 원칙)](#5-DIP의존성-역전-원칙)</br>
[6. 참고 자료](#6-참고-자료)

</br>

SOLID 원칙은 함수와 데이터 구조를 클래스로 배치하는 법, 그리고 이들 클래스를 서로 결합하는 법을 설명한다.</br>
SOLID 원칙의 목적은 아래와 같다.</br>
- 변경에 유연하다
- 이해하기 쉽다
- 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다

### 1. SRP(단일 책임 원칙)
Single Responsible Principle의 약자인 SRP는 __단일 모듈의 변경 이유는 하나, 오직 하나뿐이여야 한다__ 라는 의미를 가지고 있습니다.</br>
즉 __하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야한다.__ 라는 의미이죠.</br>

여기서 모듈은 소스 파일을 의미하며 단일 액터를 책임지는 코드를 함께 묶어주는 힘을 우리는 __응집성__ 이라고 합니다.</br>

SRP의 위반 사례로는 아래와 같은 것이 있다.</br>

#### 1. 사례 1: 우발적 중복

<img src = "" width = "350"/></br>

위 이미지에서 `Employee` 클래스는 하나의 클래스 내부의 세 가지 메소드가 서로 다른 액터를 책임지기 때문에 SRP를 위반한다.</br>
서로 다른 액터를 책임지는 메서드가 하나의 클래스 내부에 묶여버린 것이다.</br>

<img src = "" width = "350"/></br>

여기서 `calculatePay` 메소드와 `reportHours` 메소드는 편의 메소드 `regularHours`를 공유하고 있습니다.</br>

이때 CFO가 `calculatePay` 내부의 `regularHours`의 수정을 원합니다.</br>
`reportHours`를 맡고 있는 COO는 원하지 않구요.</br>

여기서 바로 문제점이 드러나 버립니다.</br>

CFO의 요청에 따라 `regularHours`가 수정되어 버린다면 COO는 날벼락을 맞고 말죠.</br>

#### 2. 사례 2: 병합
이번에는 CTO가 `Employee` 클래스의 내용을 조금 수정했다고 합시다.</br>
COO도 본인 팀 나름 계획을 세워 `Employee` 수정을 진행하였고요.</br>

이때 역시 동일한 클래스에 서로 다른 액터가 변경을 시도함에 따라 문제가 발생합니다.</br>

#### 3. 해결
우리가 모두 짐작하듯 이 문제의 해결방법은 간단합니다.</br>
각각의 메서드를 각기 다른 클래스로 분리하는 것이죠.</br>

물논 이렇게 하면 개발자가 세 가지 클래스를 인스턴스화 하여 추적해야한다는 번거로움이 발생합니다.</br>

<img src = "" width = "500"/></br>

이 대책으로 __퍼사드 패턴__ 이 존재합니다.</br>
퍼사드 패턴은 각 클래스의 객체를 생성한 뒤 요청하는 메서드를 가지는 객체로 일을 위임시킵니다.</br>

이렇게 알아본 SRP는 __메서드와 클래스 수준의 원칙__ 입니다.</br>
컴포넌트 수준에서는 __공통 폐쇄 원칙__, 그리고 아키텍쳐 수준에서는 __아키텍처 경계 생성을 책임지는 변경축__ 이 됩니다.</br>

### 2. OCP(개방 폐쇄 원칙)

### 3. LSP(리스코프 치환 원칙)

### 4. ISP(인터페이스 분리 원칙)

### 5. DIP(의존성 역전 원칙)

### 6. 참고 자료
