# 📝 TIL - 240522 CleanArchitecture Ch.3
해당 글은 마틴 파울러의 `클린아키텍처 3부 - 설계 원칙` 을 토대로 작성되었습니다.


## 학습 내용
[1. SRP(단일 책임 원칙)](#1-SRP단일-책임-원칙)</br>
[2. OCP(개방 폐쇄 원칙)](#2-OCP개방-폐쇄-원칙)</br>
[3. LSP(리스코프 치환 원칙)](#3-LSP리스코프-치환-원칙)</br>
[4. ISP(인터페이스 분리 원칙)](#4-ISP인터페이스-분리-원칙)</br>
[5. DIP(의존성 역전 원칙)](#5-DIP의존성-역전-원칙)</br>
[6. 참고 자료](#6-참고-자료)

</br>

SOLID 원칙은 함수와 데이터 구조를 클래스로 배치하는 법, 그리고 이들 클래스를 서로 결합하는 법을 설명한다.</br>
SOLID 원칙의 목적은 아래와 같다.</br>
- 변경에 유연하다
- 이해하기 쉽다
- 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다

</br>

### ✅ 1. SRP(단일 책임 원칙)
Single Responsible Principle의 약자인 SRP는 __단일 모듈의 변경 이유는 하나, 오직 하나뿐이여야 한다__ 라는 의미를 가지고 있습니다.</br>
즉 __하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야한다.__ 라는 의미이죠.</br>

여기서 모듈은 소스 파일을 의미하며 단일 액터를 책임지는 코드를 함께 묶어주는 힘을 우리는 __응집성__ 이라고 합니다.</br>

SRP의 위반 사례로는 아래와 같은 것이 있다.</br>

#### 1. 사례 1: 우발적 중복

<img src = "" width = "350"/></br>

위 이미지에서 `Employee` 클래스는 하나의 클래스 내부의 세 가지 메소드가 서로 다른 액터를 책임지기 때문에 SRP를 위반한다.</br>
서로 다른 액터를 책임지는 메서드가 하나의 클래스 내부에 묶여버린 것이다.</br>

<img src = "" width = "350"/></br>

여기서 `calculatePay` 메소드와 `reportHours` 메소드는 편의 메소드 `regularHours`를 공유하고 있습니다.</br>

이때 CFO가 `calculatePay` 내부의 `regularHours`의 수정을 원합니다.</br>
`reportHours`를 맡고 있는 COO는 원하지 않구요.</br>

여기서 바로 문제점이 드러나 버립니다.</br>

CFO의 요청에 따라 `regularHours`가 수정되어 버린다면 COO는 날벼락을 맞고 말죠.</br>

#### 2. 사례 2: 병합
이번에는 CTO가 `Employee` 클래스의 내용을 조금 수정했다고 합시다.</br>
COO도 본인 팀 나름 계획을 세워 `Employee` 수정을 진행하였고요.</br>

이때 역시 동일한 클래스에 서로 다른 액터가 변경을 시도함에 따라 문제가 발생합니다.</br>

#### 3. 해결
우리가 모두 짐작하듯 이 문제의 해결방법은 간단합니다.</br>
각각의 메서드를 각기 다른 클래스로 분리하는 것이죠.</br>

물논 이렇게 하면 개발자가 세 가지 클래스를 인스턴스화 하여 추적해야한다는 번거로움이 발생합니다.</br>

<img src = "" width = "500"/></br>

이 대책으로 __퍼사드 패턴__ 이 존재합니다.</br>
퍼사드 패턴은 각 클래스의 객체를 생성한 뒤 요청하는 메서드를 가지는 객체로 일을 위임시킵니다.</br>

이렇게 알아본 SRP는 __메서드와 클래스 수준의 원칙__ 입니다.</br>
컴포넌트 수준에서는 __공통 폐쇄 원칙__, 그리고 아키텍쳐 수준에서는 __아키텍처 경계 생성을 책임지는 변경축__ 이 됩니다.</br>

</br>

### ✅ 2. OCP(개방 폐쇄 원칙)
Open-Close Principle의 약자인 OCP는 __소프트웨어 개체는 확장에는 열려있어야 하고 변경에는 닫혀있어야 한다__ 는 의미를 가지고 있습니다.</br>
SOLID 원칙의 가장 근본적인 원칙이라고 할 수 있죠.</br>

OCP의 이해를 돕기 위한 사고실험은 아래와 같습니다.</br>

#### 사고 실험
예시를 하나 들어봅시다.</br>
재무재표를 웹페이지에 보여주는 시스템이 있습니다.</br>
웹 페이지는 데이터 스크롤, 음수는 빨강으로 표시 하는 기능을 가지고 있죠.</br>

여기서 우리는 해당 페이지의 데이터를 페이지 번호가 있고, 페이지마다 적절한 머리글과 바닥글이 있고, 표의 각 열에는 레이블이 있으며 음수는 괄호로 감싼 형태의 보고서를 출력받기 원한다고 하자.(~~많이도 바란다~~)</br>
이 경우 우리는 거의 모든 코드를 새로 짜야한다.</br>

이렇게 비효율적인 상황을 방지하기 위해서 우리가 택할 수 있는 방법은 __서로 다른 목적으로 변경되는 요소를 적절히 분리하기(SRP)__, __이들 요소 사이의 의존성을 체계화 허가(DIP)__ 가 있다.</br>
이렇게 클래스를 단위로 분할하고 이들 클래스를 이중선으로 표시한 컴포넌트 단위로 구분한 것이 아래와 같다.</br>

<img src = "" width = "500" /></br>

위 구조는 `Controller`, `Interactor`, `Database` 그리고 `Presenter`와 `View`를 담당하는 컴포넌트들로 구성되어 있다.</br>
여기서 화살표들은 __의존성__ 을 나타내는데 모든 화살표는 이중선과 한 방향으로만 교차하고 있다.</br>
즉 모든 컴포넌트의 관계는 __단방향__ 으로 이루어진다는 것이다.</br>

위 그림을 단순화 하여 정리하면 아래와 같아진다.</br>

<img src = "" width = "450" /></br>

위의 그림을 보면 모든 화살표는 `Interactor`로 흐르며 이것은 즉 `Interactor`는 다른 컴포넌트의 변경으로부터 자유로우며 제일 고수준의 __업무 규칙__ 을 포함한 컴포넌트임을 의미한다.</br>

결국 OCP는 아키텍트의 기능이 어떻게, 왜, 언제 발생하는지에 따라 기능적으로 분리하고 이를 컴포넌트의 계층 구조로 조직화 한다는 것이다.</br>
이를 통해 우리는 __저수준 컴포넌트의 변경으로부터 고수준 컴포넌트를 보호__ 할 수 있다.</br>

! 위 그림에서 Gateway 인터페이스의 존재는 __의존성 역전__ 을 위한 것.</br>
! Requester는 Controller가 Entities에 대해 너무 많이 아는 것을 막아 추이 종속성을 방지하기 위한 것.(내부 은닉)</br>

</br>

### ✅ 3. LSP(리스코프 치환 원칙)

<img src = "" width = "450"/></br>

위의 그림은 `License` 클래스를 호출하는 `Billing` 어플리케이션을 나타내고 있다.</br>
여기서 `License` 클래스는 LSP를 준수한다.(~~냅다 결론~~).</br>

그 이유는 `Billing`이 `License` 하위타입에 의존하는게 아닌 상위타입인 `License` 자체에 의존하고 있기 때문에 `Personal License`와 `Business License`는 언제나 치환될 수 있기 때문이다.</br>

이해가 안된다면 또 다른 예시인 __정사각형/직사각형 문제__ 를 살펴보자.</br>

#### 정사각형 / 직사각형 문제

<img src = "" width = "450"/></br>

여기서 `User`은 `Rectangle(직사각형)` 클래스를 호출할 수 있고 `Rectangle`의 하위타입으로 `Square(정사각형)`가 존재하고 있다.</br>

```swift
var rectangle = ...
rectangle.setWidth(5)
rectangle.setHeight(2)
print(rectangle.area() == 10)
```

이때 위와 같은 코드가 존재한다고 할 때 위 코드의 `Rectangle` 자리에 `Square`가 들어간다면 잘 작동할까?</br>
물논 답은 "아니다" 이다.</br>
`Rectangle`과 달리 `Square`은 높이와 너비가 동일하다는 특성을 가지고 있고 높이와 너비를 어떻게 설정하든 하나의 설정은 또 다른 하나로 변경되어버릴 것이다.</br>
즉 `print`문은 25나 4라는 말도안되는 결과를 내뱉게 된다.</br>
이 경우 우리는 __Rectangle은 LSP를 만족하지 않는다__ 라고 결론 지을 수 있다.</br>

POP(객체지향 프로그래밍)이 처음 나타났던 초창기에는 이 대안책으로 __상속__ 이 제안되었지만 이후 인터페이스와 구현체에도 적용되는 더 광범위한 소프트웨어 설계원칙이 지향된다.</br>

</br>

### ✅ 4. ISP(인터페이스 분리 원칙)

### ✅ 5. DIP(의존성 역전 원칙)

### 6. 참고 자료
