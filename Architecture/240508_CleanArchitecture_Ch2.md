# 📝 TIL - 240508 CleanArchitecture Ch.2
해당 글은 마틴 파울러의 `클린아키텍처 2부 - 벽돌부터 시작하기: 프로그래밍 패러다임` 을 토대로 작성되었습니다.


## 학습 내용
[1. 패러다임 개요](#1-패러다임-개요)</br>
[2. 구조적 프로그래밍](#2-구조적-프로그래밍)</br>
[3. 객체 지향 프로그래밍](#3-객체-지향-프로그래밍)<br>
[4. 함수형 프로그래밍](#4-함수형-프로그래밍)</br>
[5. 결론](#5-결론)</br>
[6. 참고 자료](#6-참고-자료)


## 🎯 학습 목표
|상태|목표|
|---|---|
|||

</br>

### 1. 패러다임 개요
각 패러다임들은 프로그래머의 권한을 박탈한다.</br>
아키텍처의 세 가지 큰 관심사인 함수, 컴포넌트 분리, 데이터 관리가 어떻게 서로 연관되어 있는지 주목하며 이후 세 가지 패러다임을 비교해보자.</br>
- 구조적 프로그래밍: 제어흐름의 직접적인 전환에 대해 규칙을 부과
- 객체 지향 프로그래밍: 제어흐름의 간접적인 전환에 대한 규칙을 부과
- 함수형 프로그래밍: 할당문에 대한 규칙 부과
</br>

### 2. 구조적 프로그래밍
데이크스트라는 __증명(proof)__ 라는 수학적인 원리를 적용하여 프로그램들이 너무 많은 세부사항을 담고 있는 문제를 해결하고자 함.</br>
goto문의 '좋은' 사용 방식은 ```if/then/else```와 ```do/while```과 같은 분기와 반복 이라는 단순한 제어구조에 해당한다는 사실을 발견.</br>
모듈이 이러한 종류의 제어 구조만을 사용한다면 증명 가능한 단위로까지 모듈을 재귀적으로 세분화 하는 것이 가능.</br>

뵘과 야코피니는 모든 프로그램을 __순차__, __분기__, __반복__ 이라는 세 가지 구조만으로 표현할 수 있다는 사실을 증명.</br>
- __순차:__ 단순 열거법을 이용해 순차 구문이 올바름을 입증할 수 있다는 사실을 보여줌.
- __분기:__ 열거법을 재적용하는 방식으로 처리.
- __반복:__ 열거법과 귀납법을 사용하여 1인 경우 올바름을 증명하고 N의 경우가 올바르다고 가정할 때 N+1이 올바름을 증명.

이후 데이크스트라의 __goto문의 해로움__ 이라는 편지가 3월호에 실림.</br>

구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 되었고 이는 결국 모듈을 기능적으로 분해할 수 있음을 의미.</br>

이를 토대로 __구조적 분석__, __구조적 설계__ 와 같은 기법이 인기를 끎.</br>

구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해할 것을 강요하고 테스트를 통해 이러한 세부 기능들이 거짓인지를 증명하려고 시도.</br>
그리고 이 증명이 실패하면 이 기능들은 목표에 부합할 만큼은 참이라고 여김.</br>

__키워드:__ 기능적 분해</br>

### 3. 객체 지향 프로그래밍
객체지향(Object-Oriented)란 무엇인지에 대한 설명이 명확하게 없다.</br>
그 중 하나의 설명은 캡슐화(encapsulation), 상속(inheritance), 다형성(polymorphism) 의 개념을 적절히 조합한 것 또는 최소한 이 세 요소들을 반드시 지원하는 것 이다.</br>

- __캡슐화:__ C언어에서는 하나의 헤더파일을 생성하면 그 헤더파일을 사용하는 쪽에서는 헤더파일의 내부 내용을 전혀 알 수 없었다. </br>하지만 이후 OO 언어들은 헤더 파일의 멤버변수의 존재를 외부에 들키는 등의 문제를 가지고 있어 OO 프로그래밍이 완벽한 캡슐화를 약화시킨다는 주장에 더 무게가 실린다.
- __상속:__ OO 언어 이전의 언어도 상속과 비슷한 기법을 사용하기는 했었다. 업캐스팅 또한 암묵적으로 이루어졌었으니 말 다했다(?).</br>어쨋든 이는 상속을 흉내낸 것이고 이 방법으로 다중상속을 구현하는 것은 굉장히 어려웠다.</br>따라서 OO언어가 완전히 새로운 개념을 만들지는 못했지만, 데이터 구조에 가면을 씌우는 일을 상당히 편리한 방식으로 제공하였다고 볼 수 있다.
- __다형성:__ 이 또한 OO가 새로 만든 것은 아니고 OO은 단지 다형성을 좀 더 안전하고 더욱 편리하게 사용할 수 있게 해주었다.</br>
다형성이 중요한 이유는 우리는 장치에 독립적인 프로그램을 원해왔고 OO의 등장으로 우리는 언제든지 플러그인 아키텍처를 사용할 수 있게 되었다.</br>
__OO 언어가 다형성을 안전하고 편리하게 제공한다는 사실은 소스 코드 의존성을 어디서든 역전시킬 수 있다는 뜻이기도 하다.__ </br>
__시스템 소스 코드 의존성 전부에 대해 방향을 결정할 수 있는 절대적인 권한을 가질 수 있다는 것, 이것이 OO가 제공하는 힘이다.__ </br>
이는 __배포 독립성__ 과 __개발 독립성__ 으로 이어진다.</br>

#### ✅ OO란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.

### 4. 함수형 프로그래밍
아키텍처를 고려할 때 왜 변수의 가변성을 염려해야할까?</br>
이는 경합 조건(Race Condition), 교착 상태(DeadLock), 동시 업데이트(Concurrent Update) 등의 문제가 모두 가변 변수로 인해 발생하기 때문이다.</br>
애플리케이션을 제대로 구조화하려면 변수를 변경하는 컴포넌트와 변경하지 않는 컴포넌트를 분리해야한다.</br>
가능한 많은 처리를 불변 컴포넌트로 옮기고 가변 컴포넌트에서는 가능한 많은 코드를 빼내야 한다는 것이다.</br>

### 5. 결론
1. 구조적 프로그래밍은 제어 흐름의 직접적인 전환에 부과되는 규율</br>
2. 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율</br>
3. 함수형 프로그래밍은 변수 할당에 부과되는 규율</br>

#### 소프트웨어는 순차, 분기, 반복, 참조로 구성된다.</br>

### 6. 참고 자료
Clean Architecture - 2부
