# 📝 TIL - 2405XX CleanArchitecture Ch.4

해당 글은 마틴 파울러의 `클린아키텍처 4부 - 컴포넌트 원칙` 을 토대로 작성되었습니다.

## 학습 내용
[1. 컴포넌트](#-1-컴포넌트)</br>
[2. 컴포넌트 응집도](#-2-컴포넌트-응집도)</br>
[3. 컴포넌트 결합](#-3-컴포넌트-결합)</br>
[4. 참고 자료](#4-참고-자료)</br>

</br>

### ✅ 1. 컴포넌트

컴포넌트는 시스템의 구성요소로 **배포할 수 있는 가장 단위** 입니다.(배포 단위)</br>
iOS에서는 .ipa 파일을 말하죠.</br>

우리는 여러 컴포넌트를 서로 링크하여 실행 가능한 단일파일로 생성할 수도 있습니다.</br>
컴포넌트는 마지막에 어떤 형태로 배포되든 반드시 독립적으로 배포 가능한, 즉 독립적으로 개발 가능한 능력을 갖추고 있어야 합니다.</br>

</br>

### ✅ 2. 컴포넌트 응집도

컴포넌트 응집도와 관련해서는 아래와 같이 세 가지 원칙을 고려해야 합니다.</br>

#### 1. REP: 재사용/릴리스 등가 원칙
**재사용 단위는 릴리스 단위와 같다** </br>

소프트웨어는 릴리스 절차를 통해 추적 관리 되어야 합니다.</br>
그렇지 않으면 재사용 컴포넌트들이 서로 호환되는지 보장할 수 있는 방법이 없고 더 나아가 개발자 입장에서 릴리스 버전 관리가 되지 않은 소프트웨엉의 변경사항을 알기란 불가능에 가깝기 때문이죠.</br>

이 원칙은 소프트웨어 설계와 아키텍처 관점에서 봤을 때 **단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 함** 을 의미합니다.</br>
이 말을 약간 다른 시각에서 이야기 해보자면 

- 하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스 할 수 있어야 한다.
- 하나의 컴포넌트로 묶인 클래스와 모듈은 버전 번호가 같아야 한다.
- 하나의 컴포넌트로 묶인 클래스와 모듈은 동일한 릴리스로 추적 관리 되어야 한다.
- 하나의 컴포넌트로 묶인 클래스와 모듈은 동일한 릴리스 문서에 포함되어야 한다.

이 모두 동일한 이야기 입니다.</br>

#### 2. CCP: 공통 폐쇄 원칙

**동일한 이유로 동일한 시점에서 변경되는 클래스를 같은 컴포넌트로 묶어라.**</br>

이 원칙은 어디서 많이 본적이 있죠?</br>

바로 SRP(단일 책임 원칙)을 컴포넌트 관점에서 다시 쓴 것입니다.</br>

결국 **같은 이유로 변경될 가능성이 있는 클래스는 모두 한곳으로 묶으라** 는 것이죠.</br>

#### 3. CRP: 공통 재사용 원칙

**컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.**</br>

공통 재사용 원칙은 클래스와 모듈을 어느 컴포넌트에 위치 시킬지 결정할 때 도움이 되는 원칙입니다.</br>
재사용 가능한 클래스는 단독으로가 아닌 재사용 모듈의 일부로써 해당 모듈의 다른 클래스와 상호작용하는 경우가 많습니다.</br>
따라서 CRP에서는 이런 클래스들이 동일한 컴포넌트 내부에서 수많은 의존성을 생성하도록 포함시켜야 한다는 것이죠.</br>
또한 CRP는 이렇게 클래스들을 묶었을 때 의존하는 컴포넌트가 해당 컴포넌트의 모든 클래스에 대해 의존하는지를 확인해야 한다고 합니다.</br>
즉 A 컴포넌트가 B 컴포넌트를 사용한다고 했을 때 A 컴포넌트 내부의 단 하나의 클래스만이 B 컴포넌트를 사용한다면 불필요한 의존성이 생긴다는 것이죠.</br>

CRP는 ISP의 포괄적인 버전입니다.</br>
사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라고 조언하죠.</br>
ISP와 동일하게 필요하지 않은 것에 의존하지 말라고 합니다</br>

#### 컴포넌트 응집도에 대한 균형 다이어그램

우리가 앞서 살펴보았던 REP, CCP, CRP은 서로 상충되는 원칙을 가지고 있습니다.</br>

<img src = “https://github.com/Diana-yjh/TIL/blob/main/Resources/CleanArchitecture_Ch4/CleanArchitecture_Ch4_Diagram.png” width = “400”/></br>
(이미지 로드 이슈: Resources/CleanArchitecture_Ch4_Diagram.png)</br>

각각 REP, CCP는 포함, CRP는 배제 원칙의 특징을 보여줍니다.</br>
우리는 여기서 균형을 이룰 방법을 찾아야 하죠.</br>

</br>


### ✅ 3. 컴포넌트 결합

컴포넌트 내부 클래스와 모듈의 응집도에 대해 다룬 앞의 내용에 이어 이번 장에서는 컴포넌트 간의 관계에 대해 설명합니다.</br>

#### 1. ADP: 의존성 비순환 원칙
우리는 개발을 할 때 다른 개발자들과 협업을 합니다.</br>
그래서 종종 마주칠 수 있는 상황 중 하나가 바로 오늘 열심히 코드를 짜고 퇴근했더니 다음날 해당 코드가 돌아가지 않는 것 입니다.</br>
ㅎ.. 생각만해도 아찔하네요.</br>

이 문제의 원인 중 하나는 내가 의존하고 있는 소스파일을 누군가가 더 늦게까지 일하며 수정한 경우 입니다.</br>
그럼 이 문제를 해결하기 위해서는 어떤 방법이 있을까요?</br>

#### 1-1. 주단위 빌드
제일 흔한 방법 중 하나는 주단위 빌드 입니다.</br>
주단위 빌드는 월요일부터 목요일까지 각자의 개발자들이 열심히 개발을 한 뒤 금요일에 다같이 만나서 코드를 통합하는 것 입니다.</br>
물논 이 방법은 프로젝트가 조금만 커져도 문제가 발생합니다.</br>

#### 1-2. 개발 환경의 분리(의존성 비순환 원칙)
이 문제를 해결할 수 있는 핵심 해결법은 문제를 일으키는 의존성을 제거하는 것 입니다.</br>
이를 위해 우리는 개발 환경을 __릴리스 가능한 컴포넌트 단위로 분리__ 할 수 있습니다.</br>
작업단위가 나뉨에 따라 서로가 서로의 코드에 영향을 줄 일이 줄어들죠.</br>

이후 담당 개발자는 해당 컴포넌트에 __릴리스 번호__ 를 부여하고 다른 개발자가 사용할 수 있도록 디렉토리를 이동시킵니다.</br>
그러고 개발자는 자신의 공간에서 해당 컴포넌트를 지속적으로 수정하고 나머지 개발자는 릴리스된 버전을 사용합니다.</br>

이 방법으로 얻을 수 있는 이점은 아래와 같습니다.</br>
- 컴포넌트의 변경이 다른 개발자에게 즉각 영향을 끼지친 않는다
- 개발자는 릴리즈된 컴포넌트에 따라 자신의 컴포넌트 수정시기를 정할 수 있다
- 코드의 통합이 작고 점진적으로 이루어진다

이 때 우리가 주의해야 할 점이 하나 있습니다.</br>
바로 __컴포넌트 사이의 의존성 구조를 반드시 관리해야한다__ 는 것이죠.</br>
이 __의존성 구조__ 에서는 __순환__ 이 있어서는 안됩니다.</br>

<img src = "https://github.com/Diana-yjh/TIL/blob/main/Resources/CleanArchitecture_Ch4/CleanArchitecture_Ch4_Components_Diagram.png" width = "450" /></br>

위 그림은 다소 전형적인 어플리케이션의 모습입니다.</br>
구조는 __방향 그래프(Directed Graph)__ 이며 컴포넌트는 __정점(Vertex)__, 의존성 관계는 __방향이 있는 간선(Directed Edge)__ 에 해당합니다.</br>
이 다이어그램의 특징 중 하나는 어느 컴포넌트에서 시작하더라도 의존성 관계를 따라가면 최초 컴포넌트로 돌아갈 수 없다는 것이죠.</br>
이 구조는 __비순환 방향 그래프(Directed Acyclic Graph, DAG)__ 라고 합니다.

여기서 `Presenter`에 집중해봅시다.</br>
`Presenter`은 변경되면 `Main`과 `View`에 영향을 줍니다.</br>
그리고 `Presenter`을 변경하고자 한다면 사용 중인 버전의 `Interactors`와 `Entities` 자체 버전만 빌드하면 끝 입니다.</br>

그럼 이제 전체적인 구조를 볼까요.</br>
이 시스템은 전체를 릴리스 해야할 때 상향식으로 진행합니다.</br>
Entities를 컴파일, 테스트, 릴리스 하고 Presenters, View, Controllers 들도 차례대로 같은 과정을 거치죠.</br>

그럼 이번엔 __순환 의존성__ 이 발생하는 경우를 확인해보겠습니다.</br>

<img src = "https://github.com/Diana-yjh/TIL/blob/main/Resources/CleanArchitecture_Ch4/CleanArchitecture_Ch4_Acyclic_DIagram.png" width = "450" /></br>

위 그림에서 `Authorizer`에 대한 `Entities`의 의존성이 발생함에 따라 순환 의존성이 생겨버렸습니다.</br>
이렇게 되면 `Database`를 수정하고자 할 때 `Interactors`, `Entities`, `Authorizer` 모두와 호환되어야 해 릴리스가 복잡해집니다.</br>

그럼 이렇게 발생한 문제를 해결하기 위해 우리는 __순환을 끊어내야__ 합니다.</br>
이를 위한 주요 메커니즘은 아래와 같습니다.</br>
- 의존성 역전 원칙(DIP)</br>
  <img src = "https://github.com/Diana-yjh/TIL/blob/main/Resources/CleanArchitecture_Ch4/CleanArchitecture_Ch4_DIP.png" width = "400"/></br>
- `Entities`와 `Authorizer`가 모두 의존하는 클래스들을 새로운 컴포넌트로 묶어 분리하기</br>
  <img src = "https://github.com/Diana-yjh/TIL/blob/main/Resources/CleanArchitecture_Ch4/CleanArchitecture_Ch4_Seperate_Components.png" width = "450"/></br>

#### 3. 하향식(top- down) 설계
이렇게 우리는 컴포넌트가 하향식 설계가 아닌 __시스템이 성장하고 변경될 때 함께 진화하는 존재__ 라는 것을 확인하였다.</br>
결국 위에서 컴포넌트 확인한 의존성 다이어그램은 어플리케이션의 빌드 가능성과 유지보수성을 보여주는 지도라는 것이다.</br>
시스템 없이는 컴포넌트 의존성 그래프는 생성될 수 없어 해당 그래프는 클래스가 구현된 이후에 생성하는 것이 좋다.</br>

#### 4. SDP: 안정된 의존성 원칙
__안정성의 방항으로(더 안정된 쪽으로) 의존하라__ </br>
설계는 정적일 수 없으며 컴포넌트의 일부는 변동성을 지니도록 설계된다.</br>
이 때 우리는 변경이 쉽지 않은 컴포넌트를 변동이 잦은 컴포넌트에 의존하게 만들어서는 안된다.</br>

|1번|<img src = "https://github.com/Diana-yjh/TIL/blob/main/Resources/CleanArchitecture_Ch4/CleanArchitecture_Ch4_Stable.png" width = "450"/>|
|---|---|
|__2번__|<img src = "https://github.com/Diana-yjh/TIL/blob/main/Resources/CleanArchitecture_Ch4/CleanArchitecture_Ch4_Unstable.png" width = "450"/>|

위 1번 그림에서 X는 __안정된 컴포넌트__ 이다.</br>
세 개의 컴포넌트가 X에 의존하며 따라서 X는 변경이 지양되기 때문이다.</br>

반대로 2번 그림의 Y는 변경될 수 있는 요인이 3 가지나 되기 때문에 __안정되지 않은 컴포넌트__ 이다.</br>

그럼 안정성 지표를 확인하는 방법은 무엇이 있을까?</br>
이 방법으로는 컴포넌트로 들어오고 나가는 의존성 개수를 세어보는 방법이 있다.</br>
- `Fan-in`: 안으로 들어오는 의존성
- `Fan-out`: 바깥으로 나가는 의존성
- `I(불안정성)`: `I` = `Fan-out`/ (`Fan-in`+`Fan-out`) , `I`는 0 일 때 최고로 안정된 상태, 1 일 때는 불안정한 상태이다.</br>

그렇다고 모든 컴포넌트가 반드시 안정적이어야 하는 것은 아니다.</br>

<img src = "https://github.com/Diana-yjh/TIL/blob/main/Resources/CleanArchitecture_Ch4/CleanArchitecture_Ch4_SDP_Unstable.png" width = "350"/></br>

이처럼 SDP가 위배되는 상황도 확인할 수 있다.</br>
이 문제를 해결하기 위해서는 우리는 DIP를 사용할 수 있다.</br>

<img src = "https://github.com/Diana-yjh/TIL/blob/main/Resources/CleanArchitecture_Ch4/CleanArchitecture_Ch4_SDP_DIP.png" width = "350"/></br>

위 그림에서 `UServer`를 우리는 __추상 컴포넌트__ 라고 부른다.</br>
